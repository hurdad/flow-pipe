syntax = "proto3";

package flowpipe.v1;

option go_package = "github.com/hurdad/flow-pipe/gen/go/flowpipe/v1;flowpipev1";

import "google/protobuf/struct.proto";
import "google/protobuf/timestamp.proto";
import "flowpipe/v1/observability.proto";

// ============================================================
// Flow (desired + observed state)
// ============================================================

message Flow {
  // Unique flow identifier.
  string name = 1;

  // Current spec version.
  uint64 version = 2;

  // Desired configuration.
  FlowSpec spec = 3;

  // Observed runtime state.
  FlowStatus status = 4;
}

// ============================================================
// Flow specification (desired state)
// ============================================================

message FlowSpec {
  // Logical flow name.
  string name = 1;

  // Immutable version assigned by the controller.
  uint64 version = 2;

  // Execution semantics for the flow.
  optional Execution execution = 5;

  // Ordered pipeline stages.
  repeated StageSpec stages = 6;

  // Queues connecting stages.
  repeated QueueSpec queues = 7;

  // User-defined metadata labels.
  map<string, string> labels = 10;

  // Flow-level observability overrides.
  optional ObservabilityConfig observability = 11;

  // Kubernetes runtime settings.
  optional KubernetesSettings kubernetes = 12;

  // Kubernetes runtime options.
  optional KubernetesOptions kubernetes_options = 13;

  // Environment variables injected into the runtime process.
  map<string, string> env = 14;
}

// Kubernetes runtime settings for flow workloads.
message KubernetesSettings {
  // Container image when using container runtime.
  optional string image = 1;

  // Image pull policy for runtime pods.
  ImagePullPolicy image_pull_policy = 2;

  // Restart policy for runtime pods.
  RestartPolicy restart_policy = 3;

  // Optional CPU affinity per stage.
  map<string, CpuSet> cpu_pinning = 4;

  // Aggregate resource intent.
  optional Resources resources = 5;
}

// Kubernetes runtime options for flow workloads.
message KubernetesOptions {
  // Additional labels to apply to runtime pods.
  map<string, string> pod_labels = 1;

  // Additional annotations to apply to runtime pods.
  map<string, string> pod_annotations = 2;

  // Service account name for runtime pods.
  optional string service_account_name = 3;

  // Image pull secrets for runtime pods.
  repeated string image_pull_secrets = 4;

  // Runtime class name for runtime pods.
  optional string runtime_class_name = 5;

  // Streaming runtime workload kind (Deployment or DaemonSet).
  StreamingWorkloadKind streaming_workload_kind = 6;

  // CronJob options for run-to-completion job workloads.
  optional KubernetesCronOptions cron = 7;
}

// CronJob options for scheduled flow runs.
message KubernetesCronOptions {
  // Cron schedule in standard format.
  string schedule = 1;

  // Optional time zone name for the schedule.
  optional string time_zone = 2;

  // Optional suspend flag for the CronJob.
  optional bool suspend = 3;

  // Optional deadline in seconds for starting missed jobs.
  optional int64 starting_deadline_seconds = 4;

  // Concurrency policy for overlapping job runs.
  CronConcurrencyPolicy concurrency_policy = 5;

  // Optional number of successful jobs to retain.
  optional int32 successful_jobs_history_limit = 6;

  // Optional number of failed jobs to retain.
  optional int32 failed_jobs_history_limit = 7;
}

// CronJob concurrency policy options.
enum CronConcurrencyPolicy {
  // Concurrency policy not specified (controller default).
  CRON_CONCURRENCY_POLICY_UNSPECIFIED = 0;

  // Allow concurrent jobs.
  CRON_CONCURRENCY_POLICY_ALLOW = 1;

  // Forbid concurrent jobs.
  CRON_CONCURRENCY_POLICY_FORBID = 2;

  // Replace concurrent jobs.
  CRON_CONCURRENCY_POLICY_REPLACE = 3;
}

// Kubernetes workload kind for streaming runtimes.
enum StreamingWorkloadKind {
  // Workload kind not specified (controller default).
  STREAMING_WORKLOAD_KIND_UNSPECIFIED = 0;

  // Use a Deployment for streaming runtimes.
  STREAMING_WORKLOAD_KIND_DEPLOYMENT = 1;

  // Use a DaemonSet for streaming runtimes.
  STREAMING_WORKLOAD_KIND_DAEMONSET = 2;
}

// Kubernetes image pull policy.
enum ImagePullPolicy {
  // Pull policy not specified (controller default).
  IMAGE_PULL_POLICY_UNSPECIFIED = 0;

  // Always pull the image.
  IMAGE_PULL_POLICY_ALWAYS = 1;

  // Pull if not present on node.
  IMAGE_PULL_POLICY_IF_NOT_PRESENT = 2;

  // Never pull the image.
  IMAGE_PULL_POLICY_NEVER = 3;
}

// Kubernetes restart policy for runtime pods.
enum RestartPolicy {
  // Restart policy not specified (controller default).
  RESTART_POLICY_UNSPECIFIED = 0;

  // Always restart the pod.
  RESTART_POLICY_ALWAYS = 1;

  // Restart on failure.
  RESTART_POLICY_ON_FAILURE = 2;

  // Never restart the pod.
  RESTART_POLICY_NEVER = 3;
}

// ============================================================
// Execution model
// ============================================================

message Execution {
  // Selected execution mode.
  ExecutionMode mode = 1;
}

enum ExecutionMode {
  // Execution mode not specified.
  EXECUTION_MODE_UNSPECIFIED = 0;

  // Long-running streaming pipeline.
  EXECUTION_MODE_STREAMING = 1;

  // Run-to-completion batch job.
  EXECUTION_MODE_JOB = 2;
}

// ============================================================
// Stage definition
// ============================================================

message StageSpec {
  // Unique stage name within the flow.
  string name = 1;

  // Stage type identifier.
  string type = 2;

  // Number of worker threads.
  uint32 threads = 3;

  // Input queue name (if any).
  optional string input_queue = 4;

  // Output queue name (if any).
  optional string output_queue = 5;

  // Opaque, plugin-owned config
  google.protobuf.Struct config = 6;

  // Optional plugin implementation override.
  optional string plugin = 7;

  // Optional real-time scheduling priority for worker threads (Linux only).
  optional uint32 realtime_priority = 8;
}

// ============================================================
// Queue definition
// ============================================================

message QueueSpec {
  // Queue name.
  string name = 1;

  // Maximum buffered elements.
  uint32 capacity = 2;

  // Optional schema definition for queue payloads.
  optional QueueSchema schema = 3;

  // Queue implementation type.
  optional QueueType type = 4;

  // Optional filesystem path for durable queue storage.
  optional string durable_path = 5;
}

message QueueSchema {
  // Runtime representation of messages in the queue.
  InMemorySchemaFormat format = 1;

  // Schema identifier.
  string schema_id = 2;

  // Schema version in the registry.
  optional uint32 version = 3;

  // Optional registry base URL override.
  optional string registry_url = 4;
}

enum InMemorySchemaFormat {
  IN_MEMORY_SCHEMA_FORMAT_UNSPECIFIED = 0;

  // Apache Arrow (columnar, immutable, zero-copy).
  IN_MEMORY_SCHEMA_FORMAT_ARROW = 1;

  // Protocol Buffers objects / decoded messages.
  IN_MEMORY_SCHEMA_FORMAT_PROTOBUF = 2;

  // FlatBuffers (zero-copy, row-oriented).
  IN_MEMORY_SCHEMA_FORMAT_FLATBUFFERS = 3;

  // JSON objects (slow, but sometimes necessary).
  IN_MEMORY_SCHEMA_FORMAT_JSON = 4;
}

enum ExternalSchemaFormat {
  EXTERNAL_SCHEMA_FORMAT_UNSPECIFIED = 0;

  // Apache Avro (schema-evolving wire/storage format).
  EXTERNAL_SCHEMA_FORMAT_AVRO = 1;

  // JSON Schema.
  EXTERNAL_SCHEMA_FORMAT_JSON = 2;

  // Protocol Buffers (binary wire format).
  EXTERNAL_SCHEMA_FORMAT_PROTOBUF = 3;

  // FlatBuffers (binary wire + zero-copy).
  EXTERNAL_SCHEMA_FORMAT_FLATBUFFERS = 4;

  // Apache Parquet (columnar file format).
  EXTERNAL_SCHEMA_FORMAT_PARQUET = 5;
}

// Queue implementation type.
enum QueueType {
  // Type not specified (defaults to in-memory queue).
  QUEUE_TYPE_UNSPECIFIED = 0;

  // In-memory bounded queue.
  QUEUE_TYPE_IN_MEMORY = 1;

  // Durable queue with on-disk persistence.
  QUEUE_TYPE_DURABLE = 2;
}

// ============================================================
// Resource intent
// ============================================================

message Resources {
  // Preferred total CPU cores.
  optional uint32 cpu_cores = 1;

  // Preferred memory allocation in MB.
  optional uint32 memory_mb = 2;

  // Named resource profile hint.
  optional string profile = 3;
}

// ============================================================
// CPU pinning hint
// ============================================================

message CpuSet {
  // CPU core identifiers.
  repeated uint32 cpu = 1;
}

// ============================================================
// Flow status (observed state)
// ============================================================

message FlowStatus {
  // Current lifecycle state.
  FlowState state = 1;

  // Human-readable status message.
  string message = 2;

  // Currently active version.
  uint64 active_version = 3;

  // Kubernetes workload name.
  string workload = 4;

  // Last controller reconciliation time.
  google.protobuf.Timestamp last_updated = 5;
}

enum FlowState {
  // State not specified.
  FLOW_STATE_UNSPECIFIED = 0;

  // Awaiting scheduling or resources.
  FLOW_STATE_PENDING = 1;

  // Being deployed or updated.
  FLOW_STATE_DEPLOYING = 2;

  // Actively running.
  FLOW_STATE_RUNNING = 3;

  // Completed successfully (jobs only).
  FLOW_STATE_SUCCEEDED = 4;

  // Execution failed.
  FLOW_STATE_FAILED = 5;

  // Explicitly stopped.
  FLOW_STATE_STOPPED = 6;
}
